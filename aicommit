#!/usr/bin/env bash
set -euo pipefail

# ---------------- CONFIG ----------------
OPENAI_API_KEY=${OPENAI_API_KEY:-}                          # optional
BASE_URL="${OPENAI_BASE_URL:-https://gen.pollinations.ai}"  # pollinations default
MODEL="${OPENAI_MODEL:-gpt-5.1-codex-mini}"
TEMP="${OPENAI_TEMPERATURE:-0.2}"
MAX="${MAX_DIFF_CHARS:-12000}"

RE='^(feat|fix|build|chore|ci|docs|style|refactor|perf|test|revert)(\([a-zA-Z0-9._/-]+\))?(!)?: .+'

ADD_ALL=false
NO_CONFIRM=false
DO_PUSH=false

# ---------------- FLAGS (-ayp / --all --no-confirm --push) ----------------
for arg in "$@"; do
  case "$arg" in
    --all) ADD_ALL=true ;;
    --no-confirm) NO_CONFIRM=true ;;
    --push) DO_PUSH=true ;;
    -[!-]*)
      for (( i=1; i<${#arg}; i++ )); do
        case "${arg:i:1}" in
          a) ADD_ALL=true ;;
          y) NO_CONFIRM=true ;;
          p) DO_PUSH=true ;;
          *) echo "Unknown flag: -${arg:i:1}" >&2; exit 1 ;;
        esac
      done
      ;;
  esac
done

# ---------------- UTIL: timer ----------------
have_py=false
command -v python3 >/dev/null 2>&1 && have_py=true

now() {
  if $have_py; then
    python3 -c 'import time; print(time.time())'
  else
    # seconds resolution fallback
    date +%s
  fi
}

elapsed() {
  local t0="$1" t1="$2"
  if $have_py; then
    python3 -c 'import sys; print(float(sys.argv[2]) - float(sys.argv[1]))' "$t0" "$t1"
  else
    echo $((t1 - t0))
  fi
}

fmt_secs() {
  local x="${1:-0}"
  if $have_py; then
    python3 -c 'import sys; print(f"{float(sys.argv[1]):.1f}s")' "$x"
  else
    printf "%ss" "$x"
  fi
}

# ---------------- UTIL: ui ----------------
SPIN_PID=""
SPIN_MSG=""

spinner_start() {
  SPIN_MSG="${1:-Working...}"
  local frames='|/-\'
  (
    local i=0
    while :; do
      printf "\r%s %c" "$SPIN_MSG" "${frames:i%${#frames}:1}"
      i=$((i+1))
      sleep 0.12
    done
  ) &
  SPIN_PID=$!
}

spinner_stop() {
  local suffix="${1:-}"
  if [[ -n "${SPIN_PID:-}" ]]; then
    kill "$SPIN_PID" 2>/dev/null || true
    wait "$SPIN_PID" 2>/dev/null || true
  fi
  SPIN_PID=""
  printf "\r\033[K%s%s\n" "$SPIN_MSG" "$suffix"
}

cleanup() {
  if [[ -n "${SPIN_PID:-}" ]]; then
    kill "$SPIN_PID" 2>/dev/null || true
    wait "$SPIN_PID" 2>/dev/null || true
  fi
  SPIN_PID=""
}
trap 'cleanup; echo; exit 130' INT
trap 'cleanup' EXIT TERM

# ---------------- JOKES ----------------
# (tăng số lượng, chia theo step + tình huống)
J_ADD=(
  "đang gom nhặt mảnh vỡ…"
  "đang dọn bãi chiến trường…"
  "đang ‘git add’ bằng niềm tin…"
  "đang nhặt từng dòng như nhặt lá…"
  "đang quét sạch dấu vết tội ác…"
  "đang thu hoạch code ngoài đồng…"
  "đang gói ghém thay đổi vào staging…"
  "đang ném mọi thứ lên thớt…"
  "đang buộc dây an toàn cho commit…"
)
J_DIFF=(
  "đang soi diff dưới kính hiển vi…"
  "đang đọc ‘tâm thư’ của staged changes…"
  "đang kiểm tra xem có lỡ tay không…"
  "đang tìm bug đang giả vờ vô tội…"
  "đang coi có ai lén nhét console.log không…"
  "đang rà từng ký tự như kiểm toán…"
  "đang đo xem độ cháy của code…"
  "đang xem lịch sử có bị bẻ cong…"
)
J_AI=(
  "đang tìm lý do cho mớ code này…"
  "đang giải thích sự hỗn loạn…"
  "đang bịa commit một cách chuyên nghiệp…"
  "đang cố hiểu bạn vừa làm gì…"
  "đang biến panic thành commit…"
  "đang gọi ‘thầy bói’ đọc diff…"
  "đang thuê ai viết message hộ…"
  "đang ép ai đó nói cho ra conventional…"
  "đang ‘dịch’ code sang tiếng người…"
  "đang xin lời sám hối từ staged…"
  "đang nặn chữ cho vừa 72 ký tự…"
)
J_FIX=(
  "đang nắn commit cho đúng chuẩn…"
  "đang dũa câu chữ cho ‘conventional’…"
  "đang vá format…"
  "đang đuổi chữ hoa ra khỏi commit…"
  "đang mài scope cho bén…"
  "đang chỉnh dấu chấm câu cho khỏi quê…"
)
J_COMMIT=(
  "đang khắc commit lên bia đá…"
  "đang chốt hạ lịch sử…"
  "đang ‘git commit’ với sự nghiêm túc giả…"
  "đang đóng dấu đỏ vào repo…"
  "đang ký tên vào timeline…"
  "đang gói commit như gói bánh chưng…"
)
J_PUSH=(
  "đang đẩy lên trời…"
  "đang phóng commit lên origin…"
  "đang gửi hàng qua không gian…"
  "đang bắn thay đổi ra internet…"
  "đang ship code không hoàn tiền…"
  "đang ném commit lên mây…"
  "đang gửi tín hiệu lên vệ tinh…"
)
J_EMPTY=(
  "không có staged changes — sạch như mới cài os."
  "repo yên bình — staged trống trơn."
  "không có gì để commit — hãy tạo drama trước."
  "staged rỗng — lịch sử vẫn đang chờ bạn."
)
J_FAIL=(
  "toang…"
  "gãy…"
  "rụng…"
  "đứt…"
  "vỡ kế hoạch…"
  "đời không như là mơ…"
  "hôm nay git không đứng về phía bạn…"
)

pick() {
  local arr_name="$1"
  eval "local n=\${#${arr_name}[@]}"
  local idx=$((RANDOM % n))
  eval "printf '%s' \"\${${arr_name}[$idx]}\""
}

# ---------------- STEP RUNNER ----------------
run_step() {
  local msg="$1"; shift
  local t0 t1 dt err
  t0="$(now)"
  spinner_start "$msg"
  err="$(mktemp)"

  if "$@" >/dev/null 2>"$err"; then
    t1="$(now)"; dt="$(elapsed "$t0" "$t1")"
    spinner_stop " (done $(fmt_secs "$dt"))"
    rm -f "$err"
    return 0
  else
    spinner_stop " ($(pick J_FAIL))"
    echo "---- error ----" >&2
    sed 's/^/  /' "$err" >&2 || true
    echo "--------------" >&2
    rm -f "$err"
    return 1
  fi
}

# ---------------- AI CALL ----------------
system=$'write a git commit message per conventional commits v1.0.0.\nplain text only.\nall lowercase.\nformat: type(scope)!: subject\nallowed types: feat fix build chore ci docs style refactor perf test revert.\nsubject: imperative, <=72 chars, no trailing period.\nadd body/footer only if necessary.\ndo not invent changes; use only the staged diff.'

call_ai() {
  local usr="$1"
  local payload resp out
  local -a auth_header=()

  [[ -n "${OPENAI_API_KEY:-}" ]] && auth_header=(-H "Authorization: Bearer $OPENAI_API_KEY")

  payload="$(
    jq -n \
      --arg m "$MODEL" \
      --arg sys "$system" \
      --arg usr "$usr" \
      --argjson t "$TEMP" \
      '{
        model: $m,
        temperature: $t,
        messages: [
          { role:"system", content: $sys },
          { role:"user",   content: $usr }
        ]
      }'
  )"

  resp="$(
    curl --fail-with-body -sS \
      --connect-timeout 10 --max-time 60 \
      --retry 2 --retry-delay 0 --retry-max-time 60 \
      -H "Content-Type: application/json" \
      -H "User-Agent: git-ai-commit/1.0" \
      "${auth_header[@]}" \
      "$BASE_URL/v1/chat/completions" \
      -d "$payload"
  )" || {
    echo "AI HTTP error:" >&2
    echo "$resp" >&2
    return 1
  }

  out="$(
    printf "%s" "$resp" | jq -r '
      if .error? then
        "ERROR: \(.error.message // .error)" | halt_error(1)
      elif .choices? then
        (.choices[0].message.content // "")
      elif .output? then
        (
          [ .output[]?
            | select(.type=="message")
            | .content[]?
            | select(.type=="output_text")
            | .text
          ] | join("")
        )
      else
        ""
      end
    '
  )" || {
    echo "AI parse/API error response:" >&2
    echo "$resp" >&2
    return 1
  }

  # strip CR only (windows), keep newlines
  printf "%s" "$out" | tr -d '\r'
}

# ---------------- MAIN ----------------
# 1) add
if $ADD_ALL; then
  run_step "$(pick J_ADD)" git add -A
fi

# 2) staged diff (no spinner; instant)
diff="$(git diff --staged || true)"
if [[ -z "$diff" ]]; then
  echo "$(pick J_EMPTY)"
  exit 0
fi

# cap diff
diff="${diff:0:$MAX}"
run_step "$(pick J_DIFF)" true

user="Staged diff:\n$diff"

# 3) AI generate
t0="$(now)"
spinner_start "$(pick J_AI)"
msg="$(call_ai "$user" || true)"
t1="$(now)"
dt="$(elapsed "$t0" "$t1")"
spinner_stop " (done $(fmt_secs "$dt"))"

[[ -n "${msg:-}" ]] || { echo "Empty AI response"; exit 1; }

# 4) validate + fix format if needed
first="$(head -n1 <<<"$msg")"
if ! [[ "$first" =~ $RE ]]; then
  t0="$(now)"
  spinner_start "$(pick J_FIX)"
  msg="$(call_ai $'fix only formatting to match conventional commits v1.0.0.\nreturn plain text only.\n\ndraft:\n'"$msg" || true)"
  t1="$(now)"
  dt="$(elapsed "$t0" "$t1")"
  spinner_stop " (done $(fmt_secs "$dt"))"

  first="$(head -n1 <<<"$msg")"
  [[ "$first" =~ $RE ]] || { echo "Invalid Conventional Commit: $first"; exit 1; }
fi

echo "-------------------------"
echo "$msg"
echo "-------------------------"

# 5) confirm
if ! $NO_CONFIRM; then
  read -r -p "Commit? [y/N] " yn
  [[ "$yn" =~ ^[Yy]$ ]] || exit 0
fi

# 6) commit
tmp="$(mktemp)"
printf "%s\n" "$msg" > "$tmp"
run_step "$(pick J_COMMIT)" git commit -F "$tmp"
rm -f "$tmp"

# 7) push
if $DO_PUSH; then
  branch="$(git rev-parse --abbrev-ref HEAD)"
  run_step "$(pick J_PUSH) (origin $branch)" git push origin "$branch"
fi
